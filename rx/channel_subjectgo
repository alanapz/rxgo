package rx

import (
	"sync"

	u "alanpinder.com/rxgo/v2/utils"
)

type ChannelSubject[T any] struct {
	lock        *sync.Mutex
	subscribers *subscriberList[T]
	signalled   bool
	value       *T
	err         error
}

var _ Subject[any] = (*ChannelSubject[any])(nil)

func NewAutoCompleteSubject[T any]() *ChannelSubject[T] {

	var lock sync.Mutex

	return &AutoCompleteSubject[T]{
		lock:        &lock,
		subscribers: NewSubscriberList[T](&lock),
	}
}

func (x *AutoCompleteSubject[T]) PostValue(value T) {
}

func (x *AutoCompleteSubject[T]) PostValue(value T) {

	x.lock.Lock()
	defer x.lock.Unlock()

	if x.signalled {
		panic("Already signalled")
	}

	x.signalled = true
	x.value = &value
	x.subscribers.PostValue(value)

	x.subscribers.PostValuesComplete()
	x.subscribers.PostErrorsComplete()
}

func (x *AutoCompleteSubject[T]) PostValuesComplete() {

	x.lock.Lock()
	defer x.lock.Unlock()

	if x.signalled {
		return
	}

	x.signalled = true
	x.subscribers.PostValuesComplete()
	x.subscribers.PostErrorsComplete()
}

func (x *AutoCompleteSubject[T]) PostError(err error) {

	x.lock.Lock()
	defer x.lock.Unlock()

	if x.signalled {
		panic("Already signalled")
	}

	x.signalled = true
	x.err = err
	x.subscribers.PostError(err)

	x.subscribers.PostValuesComplete()
	x.subscribers.PostErrorsComplete()
}

func (x *AutoCompleteSubject[T]) PostErrorsComplete() {
	x.PostValuesComplete()
}

func (x *AutoCompleteSubject[T]) Subscribe() (<-chan T, <-chan error, func()) {

	x.lock.Lock()
	defer x.lock.Unlock()

	valuesCleanup := u.NewCleanup("AutoCompleteSubject values channel")
	errorsCleanup := u.NewCleanup("AutoCompleteSubject errors channel")
	unsubscribedCleanup := u.NewCleanup("AutoCompleteSubject unsubscribed channel")

	values := u.NewChannel[T](valuesCleanup, 0)
	errors := u.NewChannel[error](errorsCleanup, 0)
	unsubscribed := u.NewChannel[u.Never](unsubscribedCleanup, 0)

	if x.signalled {

		// If we are already signalled, simply spawn a goroutine to send existing value to new channel
		// We can't simply send value as will deadlock
		go func() {

			defer unsubscribedCleanup.Cleanup()
			defer valuesCleanup.Cleanup()
			defer errorsCleanup.Cleanup()

			if x.value != nil && u.Selection(u.SelectDone(unsubscribed), u.SelectSend(values, *x.value)) == u.DoneResult {
				return
			}

			if x.err != nil && u.Selection(u.SelectDone(unsubscribed), u.SelectSend(errors, x.err)) == u.DoneResult {
				return
			}
		}()

		return values, errors, unsubscribedCleanup.Do
	}

	x.subscribers.AddSubscriber(values, errors, unsubscribed, valuesCleanup, errorsCleanup, unsubscribedCleanup)

	return values, errors, unsubscribedCleanup.Do
}
